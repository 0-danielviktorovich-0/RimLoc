#[allow(dead_code)]
#[allow(clippy::too_many_arguments)]
pub fn run_build_mod(
    po: std::path::PathBuf,
    out_mod: std::path::PathBuf,
    lang: String,
    from_root: Option<std::path::PathBuf>,
    name: String,
    package_id: String,
    rw_version: String,
    lang_dir: Option<String>,
    dry_run: bool,
    dedupe: bool,
) -> color_eyre::Result<()> {
    tracing::debug!(event = "build_mod_args", po = ?po, out_mod = ?out_mod, lang = %lang, from_root = ?from_root, name = %name, package_id = %package_id, rw_version = %rw_version, lang_dir = ?lang_dir, dry_run = dry_run);
    let lang_folder = lang_dir.unwrap_or_else(|| rimloc_import_po::rimworld_lang_dir(&lang));

    if let Some(root) = from_root {
        // Build from existing Languages/<lang> structure under `root`.
        use std::collections::BTreeMap;
        use std::fs;
        use walkdir::WalkDir;
        let mut grouped: BTreeMap<std::path::PathBuf, Vec<(String, String)>> = BTreeMap::new();
        let re = regex::Regex::new(r"(?:^|[/\\])Languages[/\\][^/\\]+[/\\](.+)$").unwrap();
        let mut total_keys = 0usize;

        for entry in WalkDir::new(&root).into_iter().filter_map(|e| e.ok()) {
            let p = entry.path();
            if !p.is_file() {
                continue;
            }
            if p.extension()
                .and_then(|e| e.to_str())
                .map_or(true, |e| !e.eq_ignore_ascii_case("xml"))
            {
                continue;
            }
            let s = p.to_string_lossy();
            if !(s.contains("/Languages/") || s.contains("\\Languages\\")) {
                continue;
            }
            if !(s.contains(&format!("/Languages/{}/", lang_folder))
                || s.contains(&format!("\\Languages\\{}\\", lang_folder)))
            {
                continue;
            }

            // Parse XML and extract keys/values via the same scanner
            // We can reuse rimloc_parsers_xml to get TransUnit with path & key/value
        }

        // Use scanner once for efficiency
        let units = rimloc_parsers_xml::scan_keyed_xml(&root)?;
        for u in units {
            let path_str = u.path.to_string_lossy();
            if !(path_str.contains("/Languages/") || path_str.contains("\\Languages\\")) {
                continue;
            }
            if !(path_str.contains(&format!("/Languages/{}/", lang_folder))
                || path_str.contains(&format!("\\Languages\\{}\\", lang_folder)))
            {
                continue;
            }
            if let Some(src) = u.source.as_deref() {
                if let Some(caps) = re.captures(&path_str) {
                    let rel = std::path::PathBuf::from(&caps[1]);
                    grouped
                        .entry(rel)
                        .or_default()
                        .push((u.key, src.to_string()));
                    total_keys += 1;
                }
            }
        }

        // Prepare About.xml
        let about_dir = out_mod.join("About");
        if !dry_run {
            let _ = fs::create_dir_all(&about_dir);
            let about_xml = about_dir.join("About.xml");
            // Minimal About
            let _ = fs::write(&about_xml, format!(
                "<ModMetaData>\n  <packageId>{}</packageId>\n  <name>{}</name>\n  <description>Translation mod (generated by RimLoc)</description>\n  <supportedVersions>\n    <li>{}</li>\n  </supportedVersions>\n</ModMetaData>\n",
                package_id, name, rw_version));
        }

        // Write or plan files
        if dry_run {
            ui_out!("build-dry-run-header");
            ui_out!("build-name", value = name.as_str());
            ui_out!("build-package-id", value = package_id.as_str());
            ui_out!("build-rw-version", value = rw_version.as_str());
            ui_out!("build-mod-folder", value = out_mod.display().to_string());
            ui_out!("build-language", value = lang_folder.as_str());
        }

        for (_i, (rel, mut items)) in grouped.into_iter().enumerate() {
            if dedupe {
                // last-wins within the file
                use std::collections::HashSet;
                let mut seen: HashSet<String> = HashSet::new();
                let mut outv: Vec<(String, String)> = Vec::new();
                for (k, v) in items.into_iter().rev() {
                    if seen.insert(k.clone()) {
                        outv.push((k, v));
                    }
                }
                outv.reverse();
                items = outv;
            }

            let full = out_mod.join("Languages").join(&lang_folder).join(&rel);
            if dry_run {
                ui_out!(
                    "import-dry-run-line",
                    path = full.display().to_string(),
                    n = items.len()
                );
            } else {
                rimloc_import_po::write_language_data_xml(&full, &items)?;
            }
            let _ = _i; // satisfy clippy in case it's unused in the future
        }

        if dry_run {
            ui_out!("build-divider");
            ui_out!("build-summary", n = total_keys);
        } else {
            ui_ok!("build-done", out = out_mod.display().to_string());
        }
        return Ok(());
    }

    if dry_run {
        let plan = rimloc_import_po::build_translation_mod_dry_run_opts(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_out!("build-dry-run-header");
        ui_out!("build-name", value = plan.mod_name);
        ui_out!("build-package-id", value = plan.package_id);
        ui_out!("build-rw-version", value = plan.rw_version);
        ui_out!(
            "build-mod-folder",
            value = plan.out_mod.display().to_string()
        );
        ui_out!("build-language", value = plan.lang_dir);
        ui_out!("build-divider");
        for (path, n) in plan.files {
            ui_out!(
                "import-dry-run-line",
                path = path.display().to_string(),
                n = n
            );
        }
        ui_out!("build-divider");
        ui_out!("build-summary", n = plan.total_keys);
    } else {
        rimloc_import_po::build_translation_mod_with_langdir_opts(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_ok!("build-done", out = out_mod.display().to_string());
    }
    Ok(())
}
