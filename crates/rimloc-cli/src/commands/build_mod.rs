#[allow(dead_code)]
#[allow(clippy::too_many_arguments)]
pub fn run_build_mod(
    po: std::path::PathBuf,
    out_mod: std::path::PathBuf,
    lang: String,
    from_root: Option<std::path::PathBuf>,
    from_game_version: Option<Vec<String>>,
    name: String,
    package_id: String,
    rw_version: String,
    lang_dir: Option<String>,
    dry_run: bool,
    dedupe: bool,
) -> color_eyre::Result<()> {
    tracing::debug!(event = "build_mod_args", po = ?po, out_mod = ?out_mod, lang = %lang, from_root = ?from_root, from_game_version = ?from_game_version, name = %name, package_id = %package_id, rw_version = %rw_version, lang_dir = ?lang_dir, dry_run = dry_run);
    let lang_folder = lang_dir.unwrap_or_else(|| rimloc_import_po::rimworld_lang_dir(&lang));

    if let Some(root) = from_root {
        // Build from existing Languages/<lang> structure under `root`.
        use std::collections::BTreeMap;
        use std::fs;
        // use walkdir::WalkDir; // no longer used
        let mut grouped: BTreeMap<std::path::PathBuf, Vec<(String, String)>> = BTreeMap::new();
        let re = regex::Regex::new(r"(?:^|[/\\])Languages[/\\][^/\\]+[/\\](.+)$").unwrap();
        let mut total_keys = 0usize;

        // Use scanner once for efficiency
        let units = rimloc_parsers_xml::scan_keyed_xml(&root)?;
        for u in units {
            let path_str = u.path.to_string_lossy();
            if !(path_str.contains("/Languages/") || path_str.contains("\\Languages\\")) {
                continue;
            }
            if !(path_str.contains(&format!("/Languages/{}/", lang_folder))
                || path_str.contains(&format!("\\Languages\\{}\\", lang_folder)))
            {
                continue;
            }
            if let Some(vers) = from_game_version.as_ref() {
                let mut matched = false;
                for ver in vers {
                    if path_str.contains(&format!("/{}/", ver))
                        || path_str.contains(&format!("\\{}\\", ver))
                        || path_str.contains(&format!("/v{}/", ver))
                        || path_str.contains(&format!("\\v{}\\", ver))
                    {
                        matched = true;
                        break;
                    }
                }
                if !matched {
                    continue;
                }
            }
            if let Some(src) = u.source.as_deref() {
                if let Some(caps) = re.captures(&path_str) {
                    let rel = std::path::PathBuf::from(&caps[1]);
                    grouped
                        .entry(rel)
                        .or_default()
                        .push((u.key, src.to_string()));
                    total_keys += 1;
                }
            }
        }

        // Prepare About.xml
        let about_dir = out_mod.join("About");
        if !dry_run {
            let _ = fs::create_dir_all(&about_dir);
            let about_xml = about_dir.join("About.xml");
            // Minimal About
            let _ = fs::write(&about_xml, format!(
                "<ModMetaData>\n  <packageId>{}</packageId>\n  <name>{}</name>\n  <description>Translation mod (generated by RimLoc)</description>\n  <supportedVersions>\n    <li>{}</li>\n  </supportedVersions>\n</ModMetaData>\n",
                package_id, name, rw_version));
        }

        // Log available version subfolders under from_root (info only)
        {
            use std::collections::BTreeSet;
            let mut versions: BTreeSet<String> = BTreeSet::new();
            if let Ok(rd) = std::fs::read_dir(&root) {
                for entry in rd.flatten() {
                    if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                        let name = entry.file_name().to_string_lossy().to_string();
                        if name.starts_with('v') || name.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
                            versions.insert(name);
                        }
                    }
                }
            }
            if !versions.is_empty() {
                tracing::info!(event = "build_available_versions", versions = ?versions);
            }
        }

        // Write or plan files
        if dry_run {
            ui_out!("build-dry-run-header");
            ui_out!("build-name", value = name.as_str());
            ui_out!("build-package-id", value = package_id.as_str());
            ui_out!("build-rw-version", value = rw_version.as_str());
            ui_out!("build-mod-folder", value = out_mod.display().to_string());
            ui_out!("build-language", value = lang_folder.as_str());
        }

        for (_i, (rel, mut items)) in grouped.into_iter().enumerate() {
            if dedupe {
                // last-wins within the file
                use std::collections::HashSet;
                let mut seen: HashSet<String> = HashSet::new();
                let mut outv: Vec<(String, String)> = Vec::new();
                for (k, v) in items.into_iter().rev() {
                    if seen.insert(k.clone()) {
                        outv.push((k, v));
                    }
                }
                outv.reverse();
                items = outv;
            }

            let full = out_mod.join("Languages").join(&lang_folder).join(&rel);
            if dry_run {
                ui_out!(
                    "import-dry-run-line",
                    path = full.display().to_string(),
                    n = items.len()
                );
            } else {
                rimloc_import_po::write_language_data_xml(&full, &items)?;
            }
            let _ = _i; // satisfy clippy in case it's unused in the future
        }

        if dry_run {
            ui_out!("build-divider");
            ui_out!("build-summary", n = total_keys);
        } else {
            ui_ok!("build-done", out = out_mod.display().to_string());
        }
        return Ok(());
    }

    if dry_run {
        let plan = rimloc_import_po::build_translation_mod_dry_run_opts(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_out!("build-dry-run-header");
        ui_out!("build-name", value = plan.mod_name);
        ui_out!("build-package-id", value = plan.package_id);
        ui_out!("build-rw-version", value = plan.rw_version);
        ui_out!(
            "build-mod-folder",
            value = plan.out_mod.display().to_string()
        );
        ui_out!("build-language", value = plan.lang_dir);
        ui_out!("build-divider");
        for (path, n) in plan.files {
            ui_out!(
                "import-dry-run-line",
                path = path.display().to_string(),
                n = n
            );
        }
        ui_out!("build-divider");
        ui_out!("build-summary", n = plan.total_keys);
    } else {
        rimloc_import_po::build_translation_mod_with_langdir_opts(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_ok!("build-done", out = out_mod.display().to_string());
    }
    Ok(())
}
