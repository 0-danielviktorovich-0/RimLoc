#[allow(dead_code)]
#[allow(clippy::too_many_arguments)]
pub fn run_build_mod(
    po: std::path::PathBuf,
    out_mod: std::path::PathBuf,
    lang: String,
    from_root: Option<std::path::PathBuf>,
    from_game_version: Option<Vec<String>>,
    name: String,
    package_id: String,
    rw_version: String,
    lang_dir: Option<String>,
    dry_run: bool,
    dedupe: bool,
) -> color_eyre::Result<()> {
    tracing::debug!(event = "build_mod_args", po = ?po, out_mod = ?out_mod, lang = %lang, from_root = ?from_root, from_game_version = ?from_game_version, name = %name, package_id = %package_id, rw_version = %rw_version, lang_dir = ?lang_dir, dry_run = dry_run);
    let lang_folder = lang_dir.unwrap_or_else(|| rimloc_import_po::rimworld_lang_dir(&lang));

    if let Some(root) = from_root {
        // Build from existing Languages/<lang> structure under `root`.
        if dry_run {
            ui_out!("build-dry-run-header");
            ui_out!("build-name", value = name.as_str());
            ui_out!("build-package-id", value = package_id.as_str());
            ui_out!("build-rw-version", value = rw_version.as_str());
            ui_out!("build-mod-folder", value = out_mod.display().to_string());
            ui_out!("build-language", value = lang_folder.as_str());
        }

        let (files, total_keys) = rimloc_services::build_from_root(
            &root,
            &out_mod,
            &lang_folder,
            from_game_version.as_ref().map(|v| v.as_slice()),
            !dry_run,
            dedupe,
        )?;
        if dry_run {
            for (path, n) in files {
                ui_out!("import-dry-run-line", path = path.display().to_string(), n = n);
            }
            ui_out!("build-divider");
            ui_out!("build-summary", n = total_keys);
        } else {
            // Minimal About.xml
            let about_dir = out_mod.join("About");
            let _ = std::fs::create_dir_all(&about_dir);
            let about_xml = about_dir.join("About.xml");
            let _ = std::fs::write(&about_xml, format!(
                "<ModMetaData>\n  <packageId>{}</packageId>\n  <name>{}</name>\n  <description>Translation mod (generated by RimLoc)</description>\n  <supportedVersions>\n    <li>{}</li>\n  </supportedVersions>\n</ModMetaData>\n",
                package_id, name, rw_version));
            ui_ok!("build-done", out = out_mod.display().to_string());
        }
        return Ok(());
    }

    if dry_run {
        let plan = rimloc_services::build_from_po_dry_run(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_out!("build-dry-run-header");
        ui_out!("build-name", value = plan.mod_name);
        ui_out!("build-package-id", value = plan.package_id);
        ui_out!("build-rw-version", value = plan.rw_version);
        ui_out!(
            "build-mod-folder",
            value = plan.out_mod.display().to_string()
        );
        ui_out!("build-language", value = plan.lang_dir);
        ui_out!("build-divider");
        for (path, n) in plan.files {
            ui_out!(
                "import-dry-run-line",
                path = path.display().to_string(),
                n = n
            );
        }
        ui_out!("build-divider");
        ui_out!("build-summary", n = plan.total_keys);
    } else {
        rimloc_services::build_from_po_execute(
            &po,
            &out_mod,
            &lang_folder,
            &name,
            &package_id,
            &rw_version,
            dedupe,
        )?;
        ui_ok!("build-done", out = out_mod.display().to_string());
    }
    Ok(())
}
